example env
DATABASE_HOST=myhost
DATABASE_PORT=myport
DATABASE_SCHEMA=mydb
DATABASE_USERNAME=myuser
DATABASE_PASSWORD=mypassword

# JWT Secrets (use strong, random strings for production!)
JWT_ACCESS_SECRET=your_super_secret_access_key_here_at_least_32_chars
JWT_REFRESH_SECRET=your_super_secret_refresh_key_here_at_least_32_chars

# Token Expiration Times (in minutes for access, days for refresh)
ACCESS_TOKEN_EXPIRATION_MINUTES=15
REFRESH_TOKEN_EXPIRATION_DAYS=7





pub async fn get_board_members_by_user_id(
        pool: &Pool<MySql>,
        user_id: i64,
        page: i64,
        per_page: i64,
    ) -> Result<Option<Vec<BoardMember>>, sqlx::error::Error> {
        let offset = (page - 1) * per_page;
        let bms = sqlx::query!(
            r#"
        SELECT id, datetime_created, board_id, user_id, is_owner, is_admin
        FROM board_member
        WHERE user_id=?
        LIMIT ?
        OFFSET ?
        "#,
            user_id,
            per_page,
            offset
        )
        .fetch_all(pool)
        .await?
        .into_iter() // Change to .into_iter() for proper ownership transfer
        .map(|row| BoardMember {
            id: row.id,
            datetime_created: row.datetime_created,
            board_id: row.board_id,
            user_id: row.user_id,
            // Convert i8 to bool
            is_owner: row.is_owner != 0,
            is_admin: row.is_admin != 0,
        })
        .collect(); // Collect into a vector

        Ok(Some(bms)) // Return wrapped in Some (as the function returns Option<Vec<_>>)
    }
